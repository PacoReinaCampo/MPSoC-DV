## HARDWARE MODEL

## CONCEPTUAL DESIGN PROCESS

The conceptual design process produces a high-level design concept that may be assessed to determine the potential for the resulting design implementation to meet the requirements. This may be accomplished using such items as functional block diagrams, design and architecture descriptions, circuit card assembly outlines, and chassis sketches.

### Conceptual Design Objectives

The conceptual design objectives are:

1. The hardware item conceptual design is developed consistent with its requirements.

2. Derived requirements produced are fed back to the requirements capture or other appropriate processes.

3. Requirement omissions and errors are provided to the appropriate processes for resolution.

### Conceptual Design Activities

Guidance for the conceptual design activities includes:

1. A high-level description should be generated for the hardware item. This may include:

   1. Architectural constraints related to safety, including those necessary to address design errors and functional, component over-stress, reliability and robustness defects.

   2. Identification of any implementation constraints on software or other system components.

2. Major components should be identified. The way they contribute to the hardware safety requirements should be determined, including the impact of unused functions.

3. Derived requirements, including the interface definition, should be fed back to the requirements capture process.

4. Requirement omissions and errors should be fed back to the appropriate process for resolution.

5. The reliability, maintenance and test features to be provided should be identified.

   Note: Consensus between the relevant parties that the conceptual design objectives have been met is recommended. Typically, a design review is used to accomplish this consensus.

## LANGUAGES

INSERT HERE

### VHDL Language

INSERT HERE

#### Overview

INSERT HERE

#### Normative references

INSERT HERE

#### Design entities and configurations

INSERT HERE

#### Subprograms and packages

INSERT HERE

#### Types

INSERT HERE

#### Declarations

INSERT HERE

#### Specifications

INSERT HERE

#### Names

INSERT HERE

#### Expressions

INSERT HERE

#### Sequential statements

INSERT HERE

#### Concurrent statements

INSERT HERE

#### Scope and visibility

INSERT HERE

#### Design units and their analysis

INSERT HERE

#### Elaboration and execution

INSERT HERE

#### Lexical elements

INSERT HERE

#### Predefined language environment

INSERT HERE

#### VHDL Procedural Interface overview

INSERT HERE

#### VHPI access functions

INSERT HERE

#### VHPI information model

INSERT HERE

#### VHPI tool execution

INSERT HERE

#### VHPI callbacks

INSERT HERE

#### VHPI value access and update

INSERT HERE

#### VHPI function reference

INSERT HERE

#### Standard tool directives

INSERT HERE

### SystemVerilog Language

INSERT HERE

#### Overview

INSERT HERE

#### Normative references

INSERT HERE

#### Design and verification building blocks

INSERT HERE

#### Scheduling semantics

INSERT HERE

#### Lexical conventions

INSERT HERE

#### Data types

INSERT HERE

#### Aggregate data types

INSERT HERE

#### Classes

INSERT HERE

#### Processes

INSERT HERE

#### Assignment statements

INSERT HERE

#### Operators and expressions

INSERT HERE

#### Procedural programming statements

INSERT HERE

#### Tasks and functions (subroutines)

INSERT HERE

#### Clocking blocks

INSERT HERE

#### Interprocess synchronization and communication

INSERT HERE

#### Assertions

INSERT HERE

#### Checkers

INSERT HERE

#### Constrained random value generation

INSERT HERE

#### Functional coverage

INSERT HERE

#### Utility system tasks and system functions

INSERT HERE

#### Input/output system tasks and system functions

INSERT HERE

#### Compiler directives

INSERT HERE

#### Modules and hierarchy

INSERT HERE

#### Programs

INSERT HERE

#### Interfaces

INSERT HERE

#### Packages

INSERT HERE

#### Generate constructs

INSERT HERE

#### Gate-level and switch-level modeling

INSERT HERE

#### User-defined primitives

INSERT HERE

#### Specify blocks

INSERT HERE

#### Timing checks

INSERT HERE

#### Backannotation using the standard delay format

INSERT HERE

#### Configuring the contents of a design

INSERT HERE

#### Protected envelopes

INSERT HERE

#### Direct programming interface

INSERT HERE

#### Programming language interface (PLI/VPI) overview

INSERT HERE

#### VPI object model diagrams

INSERT HERE

#### VPI routine definitions

INSERT HERE

#### Assertion API

INSERT HERE

#### Code coverage control and API

INSERT HERE

#### Data read API

INSERT HERE
